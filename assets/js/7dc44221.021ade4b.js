"use strict";(self.webpackChunkflashbot_docs=self.webpackChunkflashbot_docs||[]).push([[5724],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>m});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=n.createContext({}),l=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(a),u=r,m=d["".concat(c,".").concat(u)]||d[u]||h[u]||i;return a?n.createElement(m,o(o({ref:t},p),{},{components:a})):n.createElement(m,o({ref:t},p))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[d]="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=a[l];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},5510:(e,t,a)=>{a.r(t),a.d(t,{contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=a(7462),r=(a(7294),a(3905));const i={title:"codebase - deep dive"},o=void 0,s={unversionedId:"flashbots-data/deprecated/mev-inspect-rs/inspect-codebase-deep-dive",id:"flashbots-data/deprecated/mev-inspect-rs/inspect-codebase-deep-dive",isDocsHomePage:!1,title:"codebase - deep dive",description:"A deep dive into the codebase, particularly for those who are looking to get familiar with both Rust and the inspect codebase",source:"@site/docs/flashbots-data/deprecated/mev-inspect-rs/inspect-codebase-deep-dive.mdx",sourceDirName:"flashbots-data/deprecated/mev-inspect-rs",slug:"/flashbots-data/deprecated/mev-inspect-rs/inspect-codebase-deep-dive",permalink:"/flashbots-data/deprecated/mev-inspect-rs/inspect-codebase-deep-dive",tags:[],version:"current",frontMatter:{title:"codebase - deep dive"}},c=[{value:"<code>main.rs</code>",id:"mainrs",children:[{value:"<code>main()</code>",id:"main",children:[]},{value:"<code>run()</code>",id:"run",children:[]},{value:"Inspecting a tx",id:"inspecting-a-tx",children:[]},{value:"Inspecting a block",id:"inspecting-a-block",children:[]},{value:"<code>src/prices.rs</code>",id:"srcpricesrs",children:[]},{value:"Sample inspector - <code>src/inspectors/aave.rs</code>",id:"sample-inspector---srcinspectorsaavers",children:[]},{value:"Deriving from Traits",id:"deriving-from-traits",children:[]}]}],l={toc:c};function p(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},l,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A deep dive into the codebase, particularly for those who are looking to get familiar with both Rust and the inspect codebase"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Notes courtesy of Will Drevo, ",(0,r.kt)("a",{parentName:"em",href:"https://github.com/worldveil/mev-inspect-rs/blob/master/NOTES.md"},"source"))),(0,r.kt)("h2",{id:"mainrs"},(0,r.kt)("inlineCode",{parentName:"h2"},"main.rs")),(0,r.kt)("h3",{id:"main"},(0,r.kt)("inlineCode",{parentName:"h3"},"main()")),(0,r.kt)("p",null,"This is where the execution begins, in the ",(0,r.kt)("inlineCode",{parentName:"p"},"main()")," function. Note it is an async function, which returns a Future. ",(0,r.kt)("a",{parentName:"p",href:"https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html"},"Read more here"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/gumdrop/0.5.0/gumdrop/trait.Options.html"},"gumdrop::Options")," package (crate) is used for command line option parsing. The order of arguments here matters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'# will work\n./target/release/mev-inspect -u http://localhost:8080 tx 0xa72072f5041bcde89c560ba12cc00b22a87779ee369dbff81a78bba26d35e989\n\n# won\'t parse url\n./target/release/mev-inspect tx 0xa72072f5041bcde89c560ba12cc00b22a87779ee369dbff81a78bba26d35e989 -u http://localhost:8080\n# will return "unrecognized option `-u`"\n')),(0,r.kt)("p",null,"We parse the arguments with ",(0,r.kt)("inlineCode",{parentName:"p"},"Opts::parse_args_default_or_exit()"),". Next we want to retrieve a tx from a provider (ETH node), but we want to check if it's in the cache."),(0,r.kt)("p",null,"We use this line ",(0,r.kt)("inlineCode",{parentName:"p"},"let Some(ref cache) = opts.cache")," to test for this. ",(0,r.kt)("inlineCode",{parentName:"p"},"opts.cache")," is an ",(0,r.kt)("inlineCode",{parentName:"p"},"Option<PathBuf>"),", meaning it either has no value (null), or is a ",(0,r.kt)("inlineCode",{parentName:"p"},"PathBuf"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"Some(&Option<PathBuf>)")," returns true if the reference is non-null. Additionally, these two are the same:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// using ref operator\nlet Some(ref cache) = opts.cache\n// is identical to\nlet Some(cache) = &opts.cache\n")),(0,r.kt)("p",null,"Then we create a provider, either the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/ethers-providers/0.2.2/ethers_providers/struct.Provider.html"},"ethers::providers::Provider"),", or the cached version, which reads from disk."),(0,r.kt)("h3",{id:"run"},(0,r.kt)("inlineCode",{parentName:"h3"},"run()")),(0,r.kt)("p",null,"This is a complex function definition:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"async fn run<M: Middleware + Clone + 'static>(provider: M, opts: Opts) -> anyhow::Result<()> { ... }\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"takes the provider & options as input"),(0,r.kt)("li",{parentName:"ul"},"returns an ",(0,r.kt)("a",{parentName:"li",href:"https://docs.rs/anyhow/1.0.0/anyhow/type.Result.html"},"anyhow:::Result"),", which is some nice syntactic sugar around catching and printing context and a backtrace if something goes wrong. See ",(0,r.kt)("a",{parentName:"li",href:"https://docs.rs/anyhow/1.0.0/anyhow/trait.Context.html"},"here")," specifically for how to add context inside a function."),(0,r.kt)("li",{parentName:"ul"},"defines a type ",(0,r.kt)("inlineCode",{parentName:"li"},"M")," that accepts any type that implements the Middleware, Clone, and ",(0,r.kt)("a",{parentName:"li",href:"https://doc.rust-lang.org/rust-by-example/scope/lifetime/static_lifetime.html#trait-bound"},"static lifetime")," traits. This is like an interface in Java. In our code, you can see how this was done for ",(0,r.kt)("inlineCode",{parentName:"li"},"CachedProvider")," (src/cached_provider.rs).")),(0,r.kt)("p",null,"We wrap our provider in a reference counter ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/sync/struct.Arc.html"},"std::styc::Arc"),", which is the ",(0,r.kt)("a",{parentName:"p",href:"https://stackoverflow.com/a/49834496"},"C++ equvilent of std::shared_ptr"),", inorder to prevent memory leaks."),(0,r.kt)("p",null,"We create a ",(0,r.kt)("inlineCode",{parentName:"p"},"mev_inspect::HistoricalPrice")," object, giving it a provider, the price coming from Uniswap."),(0,r.kt)("p",null,"The inspectors are added to a vector. They are encased in ",(0,r.kt)("inlineCode",{parentName:"p"},"std::Box"),"es, which tells Rust to put these objects on the heap. This might seem silly at first (...after all, elements in a variable sized data structure like ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec")," (vector) ",(0,r.kt)("a",{parentName:"p",href:"https://stackoverflow.com/a/43642518"},"are stored in the heap"),"), but since we are using generics to hold a list of objects of a different type but all implement the same interface (ie: ",(0,r.kt)("inlineCode",{parentName:"p"},"Vec<Box<dyn Inspector>>"),"), the Box has the additional benefit of preventing the compiler from complaining about not knowing how much memory to set aside a prioi. If you remove the std::Box encasement, you'll get:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"the size for values of type `dyn mev_inspect::Inspector` cannot be known at compilation time\n\ndoesn't have a size known at compile-time\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/keyword.dyn.html"},(0,r.kt)("inlineCode",{parentName:"a"},"dyn")," keyword")," isn't strictly necessary (the compiler will make this trait dynamically dispatched), but know that it's depcrated and you'll get a warning."),(0,r.kt)("p",null,"Next we create a vector of reducers."),(0,r.kt)("p",null,"After that, we create a processor."),(0,r.kt)("p",null,"The connection between these different types seems to be:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Inspectors"),' are "parsers" that know how a given contract is set up, and are able to extract necessary fields'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Reducers"),' are "checkers" that examine extracted fields for different MEV actions'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Processor")," is a coordinating object that takes inspectors and parsers to inspect transactions")),(0,r.kt)("p",null,"Next we create a database connection."),(0,r.kt)("p",null,"Next we match on command, but if it's a tx, we inspect."),(0,r.kt)("h3",{id:"inspecting-a-tx"},"Inspecting a tx"),(0,r.kt)("p",null,"We create a ",(0,r.kt)("inlineCode",{parentName:"p"},"mev_inspect::types::Inspection"),". This seems to choose the correct inspector and from that extracts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"status (success/fail)"),(0,r.kt)("li",{parentName:"ul"},"actions that happened, which can be any of the ones described ",(0,r.kt)("a",{parentName:"li",href:"inspect-codebase-design"},"here")),(0,r.kt)("li",{parentName:"ul"},"protocols involved"),(0,r.kt)("li",{parentName:"ul"},"the sender, contract (if any), and proxy contract (if any) of the tx"),(0,r.kt)("li",{parentName:"ul"},"tx hsh & block height")),(0,r.kt)("p",null,"We query the provider for:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the gas_used (from receipt)"),(0,r.kt)("li",{parentName:"ul"},"the gas_price (from tx)")),(0,r.kt)("p",null,"With the inspection, gas_price, gas_used, and pricing in hand, we can coalesce into a ",(0,r.kt)("inlineCode",{parentName:"p"},"mev_inspect::types::Evaluation")," struct which holds:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"the ",(0,r.kt)("inlineCode",{parentName:"li"},"mev_inspect::types::Inspection")," object"),(0,r.kt)("li",{parentName:"ul"},"gas_used, gas_price"),(0,r.kt)("li",{parentName:"ul"},"actions involved"),(0,r.kt)("li",{parentName:"ul"},"profit made!")),(0,r.kt)("p",null,"Finally, we insert the evaluation into the database."),(0,r.kt)("h3",{id:"inspecting-a-block"},"Inspecting a block"),(0,r.kt)("p",null,"If the command is instead for a range of blocks, we iterate through this range one by one and process the block given the usual suspects:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"process_block(&mut lock, block, &provider, &processor, &mut db, &prices).await?\n")),(0,r.kt)("h3",{id:"srcpricesrs"},(0,r.kt)("inlineCode",{parentName:"h3"},"src/prices.rs")),(0,r.kt)("p",null,"First, generate the ABI with ",(0,r.kt)("a",{parentName:"p",href:"https://docs.rs/ethers-contract/0.1.3/ethers_contract/macro.abigen.html"},"ethers::contract::abigen")," macro for the Uniswap contract, and store it in the ",(0,r.kt)("inlineCode",{parentName:"p"},"abi/")," folder. This will help us decode binary data from the transactions that interact with this contract. There are many resources on this, but see ",(0,r.kt)("a",{parentName:"p",href:"https://ethereum.stackexchange.com/a/1171/34397"},"SO answer here"),"."),(0,r.kt)("h3",{id:"sample-inspector---srcinspectorsaavers"},"Sample inspector - ",(0,r.kt)("inlineCode",{parentName:"h3"},"src/inspectors/aave.rs")),(0,r.kt)("p",null,"This is the inspector for Aave."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/keyword.impl.html"},"As is customary in Rust"),", we define a ",(0,r.kt)("inlineCode",{parentName:"p"},"struct")," for the data fields, and an ",(0,r.kt)("inlineCode",{parentName:"p"},"impl")," for the methods on the object itself."),(0,r.kt)("p",null,"Aave inspector doesn't need a provider because it can simply load the ABI included in the repo."),(0,r.kt)("p",null,"Next we implment the Inspector interface for the Aave object, which is a function that takes in a mutable inspection object that we'll write fields to as a result of the inspection logic."),(0,r.kt)("h3",{id:"deriving-from-traits"},"Deriving from Traits"),(0,r.kt)("p",null,"It seems in rust that having structs derive from traits like ",(0,r.kt)("inlineCode",{parentName:"p"},"Debug")," is universally a good idea, but there are some others to be careful of. ",(0,r.kt)("a",{parentName:"p",href:"https://users.rust-lang.org/t/what-traits-should-i-normally-derive/484/9"},"Good post on the subject here"),"."))}p.isMDXComponent=!0}}]);