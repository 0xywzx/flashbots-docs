"use strict";(self.webpackChunkflashbot_docs=self.webpackChunkflashbot_docs||[]).push([[9385],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>f});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=n.createContext({}),l=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},u=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),h=l(a),d=r,f=h["".concat(c,".").concat(d)]||h[d]||p[d]||o;return a?n.createElement(f,s(s({ref:t},u),{},{components:a})):n.createElement(f,s({ref:t},u))}));function f(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,s=new Array(o);s[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[h]="string"==typeof e?e:r,s[1]=i;for(var l=2;l<o;l++)s[l]=a[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},638:(e,t,a)=>{a.r(t),a.d(t,{contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var n=a(7462),r=(a(7294),a(3905));const o={title:"coinbase.transfer()"},s=void 0,i={unversionedId:"flashbots-auction/searchers/advanced/coinbase-payment",id:"flashbots-auction/searchers/advanced/coinbase-payment",isDocsHomePage:!1,title:"coinbase.transfer()",description:"Flashbots allows you to pay validators for your transactions through a smart contract by using block.coinbase.transfer(AMOUNTTOTRANSFER). This smart contract function transfers Ethereum from the contract to the address of the validator who proposes a block. The Flashbots builder will treat fees through coinbase transfers in the same way they do normal transaction fees, which is to say that 1 wei of coinbase payments is equivalent to 1 wei paid through transaction fees. This provides significant benefits to Flashbots users:",source:"@site/docs/flashbots-auction/searchers/advanced/coinbase-payment.mdx",sourceDirName:"flashbots-auction/searchers/advanced",slug:"/flashbots-auction/searchers/advanced/coinbase-payment",permalink:"/flashbots-auction/searchers/advanced/coinbase-payment",tags:[],version:"current",frontMatter:{title:"coinbase.transfer()"},sidebar:"docs",previous:{title:"Understanding Bundles",permalink:"/flashbots-auction/searchers/advanced/understanding-bundles"},next:{title:"Bundle Pricing",permalink:"/flashbots-auction/searchers/advanced/bundle-pricing"}},c=[{value:"Managing payments to coinbase.address when it is a contract",id:"managing-payments-to-coinbaseaddress-when-it-is-a-contract",children:[]}],l={toc:c};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},l,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Flashbots allows you to pay validators for your transactions through a smart contract by using ",(0,r.kt)("inlineCode",{parentName:"p"},"block.coinbase.transfer(AMOUNT_TO_TRANSFER)"),". This smart contract function transfers Ethereum from the contract to the address of the validator who proposes a block. The Flashbots builder will treat fees through coinbase transfers in the same way they do normal transaction fees, which is to say that 1 wei of coinbase payments is equivalent to 1 wei paid through transaction fees. This provides significant benefits to Flashbots users:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"You can condition payment to the validator on some criteria being met"),(0,r.kt)("li",{parentName:"ul"},"Related, you can only pay for successful transactions, not failures"),(0,r.kt)("li",{parentName:"ul"},"You can pay for a transaction from account X with ETH from account Y (see: searcher sponsored transaction repo ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/flashbots/searcher-sponsored-tx"},"here"),")")),(0,r.kt)("p",null,"Here's an example from our open source simple arbitrage bot of how paying through coinbase transfers work:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function uniswapWeth(uint256 _wethAmountToFirstMarket, uint256 _ethAmountToCoinbase, address[] memory _targets, bytes[] memory _payloads) external onlyExecutor payable {\n    require (_targets.length == _payloads.length);\n    uint256 _wethBalanceBefore = WETH.balanceOf(address(this));\n    WETH.transfer(_targets[0], _wethAmountToFirstMarket);\n    for (uint256 i = 0; i < _targets.length; i++) {\n        (bool _success, bytes memory _response) = _targets[i].call(_payloads[i]);\n        require(_success); _response;\n    }\n\n    uint256 _wethBalanceAfter = WETH.balanceOf(address(this));\n    require(_wethBalanceAfter > _wethBalanceBefore + _ethAmountToCoinbase);\n    if (_ethAmountToCoinbase == 0) return;\n\n    uint256 _ethBalance = address(this).balance;\n    if (_ethBalance < _ethAmountToCoinbase) {\n        WETH.withdraw(_ethAmountToCoinbase - _ethBalance);\n    }\n    block.coinbase.transfer(_ethAmountToCoinbase);\n}\n")),(0,r.kt)("p",null,"The above smart contract code will attempt to capitalize on arbitrage opportunities. If it does not make money doing so then the transaction will fail."),(0,r.kt)("p",null,"For more information on how coinbase transfers are priced see the ",(0,r.kt)("a",{parentName:"p",href:"/flashbots-auction/searchers/advanced/bundle-pricing"},"bundle pricing page"),"."),(0,r.kt)("h2",{id:"managing-payments-to-coinbaseaddress-when-it-is-a-contract"},"Managing payments to coinbase.address when it is a contract"),(0,r.kt)("p",null,"Validators will occasionally have a smart contract listed as their block.coinbase address. This changes the expected behavior of making payments to block.coinbase. Specifically it costs more gas to transfer ETH to block.coinbase if it is a contract than if it is an EOA, and as such many searchers will underestimate their gas consumption and their bundles will fail for validators who use contracts instead."),(0,r.kt)("p",null,"To handle this edge case searchers can up their gas limit to accomodate the additional payment to validators and call block.coinbase in the following way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"block.coinbase.call{value: _ethAmountToCoinbase}(new bytes(0));\n")),(0,r.kt)("p",null,"However, searchers should be acutely aware of the risk of ",(0,r.kt)("a",{parentName:"p",href:"https://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21"},"reentrancy attacks"),", as calling coinbase in this way temporarily gives execution to a third party, and typically payments to coinbase are made after checks for profit. Moreover, searchers should be aware that supporting payments to coinbase addresses that are contracts will cause their gas consumption to go up, and as a result their bundle gas price to go down. This is a tradeoff that should be considered."))}u.isMDXComponent=!0}}]);